# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1p85FWcmog01MGh5ImsP4CHgG5RkO-GH6
"""

from flask import Flask, request, jsonify
from flask_cors import CORS
from sentence_transformers import SentenceTransformer
from sklearn.metrics.pairwise import cosine_similarity
import networkx as nx
from transformers import BartForConditionalGeneration, BartTokenizer
import torch
import nltk
import re
import string

# NLTK setup
nltk.data.path.append("C:/Users/sathvik/AppData/Roaming/nltk_data")
nltk.download('punkt')
nltk.download('punkt_tab')

# Initialize the Flask app
app = Flask(__name__)
CORS(app)

# Setup for Extractive Summarization (TextRank)
#nltk.download('punkt')
extractive_embedder = SentenceTransformer('all-mpnet-base-v2')

# Setup for Abstractive Summarization (BART)
device = "cuda" if torch.cuda.is_available() else "cpu"
abstractive_model = BartForConditionalGeneration.from_pretrained("facebook/bart-large-cnn").to(device)
abstractive_tokenizer = BartTokenizer.from_pretrained("facebook/bart-large-cnn")

def clean_text(text):
    if isinstance(text, str):
        text = text.lower()
        text = re.sub(r'\d+', '', text)
        text = text.translate(str.maketrans('', '', string.punctuation))
        text = re.sub(r'\s+', ' ', text).strip()
    return text


def preprocess_text(text):
    return [s.strip() for s in nltk.sent_tokenize(text) if len(s) > 20]


def build_similarity_matrix(embeddings, threshold=0.3):
    sim_matrix = cosine_similarity(embeddings)
    sim_matrix[sim_matrix < threshold] = 0
    return sim_matrix


# Extractive Summarizer
def extractive_summarize(text, num_sentences=3):
    sentences = preprocess_text(text)
    if len(sentences) <= num_sentences:
        return ' '.join(sentences)

    embeddings = extractive_embedder.encode(sentences, convert_to_tensor=True)
    sim_matrix = build_similarity_matrix(embeddings.cpu().numpy())

    nx_graph = nx.from_numpy_array(sim_matrix)
    scores = nx.pagerank(nx_graph)
    ranked = sorted(((scores[i], s) for i, s in enumerate(sentences)), reverse=True)

    return ' '.join([s for _, s in ranked[:num_sentences]])

# Abstractive Summarizer (BART)
def abstractive_summarize(text, max_length=150, min_length=30):
    inputs = abstractive_tokenizer(text, return_tensors="pt", truncation=True, max_length=1024).to(device)
    summary_ids = abstractive_model.generate(inputs["input_ids"], max_length=max_length, min_length=min_length, num_beams=4)
    return abstractive_tokenizer.decode(summary_ids[0], skip_special_tokens=True)

def categorize_email(text):
    text = text.lower()

    categories = {
    "Business": [
        "meeting", "invoice", "client", "project", "business", "contract", "proposal",
        "follow-up", "deadline", "agenda", "minutes", "presentation", "collaboration",
        "briefing", "corporate", "RFP", "budget", "strategy", "QBR", "approval", "review"
    ],
    "Personal": [
        "birthday", "party", "dinner", "hangout", "family", "friend", "vacation",
        "baby", "wedding", "love", "miss you", "photos", "memories", "get together",
        "catch up", "congrats", "invitation", "picnic", "trip", "home", "reunion"
    ],
    "Security": [
        "password", "security", "unauthorized", "breach", "login", "alert", "suspicious",
        "2FA", "verification", "code", "access", "device", "login attempt", "locked",
        "firewall", "phishing", "malware", "account recovery", "compromised", "credential"
    ],
    "Transactional": [
        "payment", "transaction", "receipt", "billed", "amount", "credited", "debited",
        "invoice", "refunded", "bank", "charged", "transfer", "statement", "ACH",
        "billing", "balance", "payout", "deposit", "confirmation", "cleared", "processed"
    ],
    "Order Alert": [
        "order", "shipped", "delivered", "tracking", "shipment", "package",
        "dispatched", "expected delivery", "arriving", "carrier", "estimated delivery",
        "tracking number", "return", "out for delivery", "courier", "pickup", "fulfilled"
    ],
    "Promotional": [
        "offer", "discount", "deal", "promo", "sale", "limited time", "coupon",
        "exclusive", "save", "flash sale", "bargain", "clearance", "special price",
        "early access", "voucher", "promotion", "hot deal", "lowest price", "last chance"
    ],
    "Renewal": [
        "renewal", "subscription", "expires", "expiring", "membership", "upgrade",
        "extend", "auto-renew", "plan", "renew now", "annual", "monthly", "trial ending",
        "your plan", "update plan", "upgrade plan", "license", "subscription notice"
    ]
}

    scores = {category: sum(keyword in text for keyword in keywords) for category, keywords in categories.items()}
    best_match = max(scores, key=scores.get)

    return best_match if scores[best_match] > 0 else "Uncategorized"


@app.route('/summarize', methods=['POST'])
def summarize_email():
    try:
        data = request.get_json(force=True)

        email_content = data.get('email_content')
        if not email_content:
            return jsonify({'error': 'Missing email_content'}), 400

        from_email = data.get('from_email', 'unknown')
        received_date = data.get('received_date', 'unknown')
        received_time = data.get('received_time', 'unknown')
        action_to_take = data.get('action_to_take', 'Review')

        # Summarize email using both methods
        extractive_summary = extractive_summarize(email_content)
        abstractive_summary = abstractive_summarize(email_content)
        segment = categorize_email(email_content) 
        # Construct response
        result = {
            'From': from_email,
            'Date': received_date,
            'Time': received_time,
            'Action': action_to_take,
            'Extractive Summary': extractive_summary,
            'Abstractive Summary': abstractive_summary,
            'Segment': segment
        }

        return jsonify(result)

    except Exception as e:
        return jsonify({'error': 'Internal server error', 'details': str(e)}), 500

if __name__ == '__main__':
    app.run(debug=True, host='0.0.0.0', port=5000)